import itertools
import json
import os
import sys

import click
import sentry_sdk
from click_aliases import ClickAliasedGroup
from sentry_sdk.integrations.atexit import AtexitIntegration

import divio_cli

from . import exceptions, localdev, messages, settings
from .check_system import check_requirements, check_requirements_human
from .cloud import CloudClient
from .excepthook import DivioExcepthookIntegration, divio_shutdown
from .upload.addon import upload_addon
from .upload.boilerplate import upload_boilerplate
from .utils import (
    get_cp_url,
    get_git_checked_branch,
    hr,
    launch_url,
    open_application_cloud_site,
    table,
)
from .context import Context, pass_cli_context, DEFAULT_ZONE
from .validators.addon import validate_addon
from .validators.boilerplate import validate_boilerplate


try:
    import ipdb as pdb
except ImportError:
    import pdb


@click.group(
    cls=ClickAliasedGroup,
    context_settings={"help_option_names": ["--help", "-h"]},
)
@click.option(
    "-d",
    "--debug/--no-debug",
    default=False,
    help="Drop into the debugger if command execution raises an exception.",
)
@click.option(
    "-z",
    "--zone",
    default=DEFAULT_ZONE,
    help="Specify the Divio zone. Defaults to divio.com.",
)
@click.option(
    "-s",
    "--sudo",
    default=False,
    is_flag=True,
    help="Run as sudo?",
    hidden=True,
)
@click.pass_context
def cli(ctx, debug, zone, sudo):
    if sudo:
        click.secho("Running as sudo", fg="red")

    # TODO: Validate zone endpoint, drop https, etc

    ctx.obj = Context()
    ctx.obj.load_global_context(
        zone=zone,
        debug=debug,
        sudo=sudo,
        git_host_override=os.environ.get("DIVIO_GIT_HOST"),
    )

    if debug:

        def exception_handler(type, value, traceback):
            click.secho(
                "\nAn exception occurred while executing the requested "
                "command:",
                fg="red",
            )
            hr(fg="red")
            sys.__excepthook__(type, value, traceback)
            click.secho("\nStarting interactive debugging session:", fg="red")
            hr(fg="red")
            pdb.post_mortem(traceback)

        sys.excepthook = exception_handler
    else:
        sentry_sdk.init(
            ctx.obj.config.get_sentry_dsn(),
            traces_sample_rate=0,
            release=divio_cli.__version__,
            server_name="client",
            integrations=[
                DivioExcepthookIntegration(),
                AtexitIntegration(callback=divio_shutdown),
            ],
        )

    try:
        is_version_command = sys.argv[1] == "version"
    except IndexError:
        is_version_command = False

    # skip if 'divio version' is run
    if not is_version_command:
        # check for newer versions
        update_info = ctx.obj.config.check_for_updates()
        if update_info["update_available"]:
            click.secho(
                "New version {} is available. Type `divio version` to "
                "show information about upgrading.".format(
                    update_info["remote"]
                ),
                fg="yellow",
            )


def login_token_helper(ctx, value):
    if not value:
        url = ctx.obj.client.get_access_token_url()
        click.secho("Your browser has been opened to visit: {}".format(url))
        launch_url(url)
        value = click.prompt(
            "Please copy the access token and paste it here. (your input is not displayed)",
            hide_input=True,
        )

    # Detect pasting shortcut malfunction (Windows users)
    # When this shortcut is disabled then the character \x16
    # (which will appear as ^V) is generated by the terminal when trying to use it.
    if "".join(set(value)) == "\x16":
        click.secho(
            "\nThe access token provided indicates a copy/paste malfunction.\nRead more here: https://r.divio.com/divio-login-windows-users.",
            fg="yellow",
        )
    return value


@cli.command()
@click.argument("token", required=False)
@click.option(
    "--check",
    is_flag=True,
    default=False,
    help="Check for current login status.",
)
@pass_cli_context
def login(ctx, token, check):
    """Authorise your machine with the Divio Control Panel."""
    success = True
    if check:
        success, msg = ctx.client.check_login_status()
    else:
        token = login_token_helper(ctx, token)
        msg = ctx.client.login(token)

    click.echo(msg)
    sys.exit(0 if success else 1)


@cli.group(cls=ClickAliasedGroup, aliases=["project"])
def app():
    """Manage your application"""


@app.command(name="list")
@click.option(
    "-g",
    "--grouped",
    is_flag=True,
    default=False,
    help="Group by organisation.",
)
@click.option("--json", "as_json", is_flag=True, default=False)
@pass_cli_context()
def application_list(ctx, grouped, as_json):
    """List all your applications."""
    api_response = ctx.client.get_applications()

    if as_json:
        click.echo(json.dumps(api_response, indent=2, sort_keys=True))
        return

    header = ("ID", "Slug", "Name", "Organisation")

    # get all users + organisations
    groups = {
        "users": {
            account["id"]: {"name": "Personal", "applications": []}
            for account in api_response["accounts"]
            if account["type"] == "user"
        },
        "organisations": {
            account["id"]: {"name": account["name"], "applications": []}
            for account in api_response["accounts"]
            if account["type"] == "organisation"
        },
    }

    # sort websites into groups
    for website in api_response["websites"]:
        organisation_id = website["organisation_id"]
        if organisation_id:
            owner = groups["organisations"][website["organisation_id"]]
        else:
            owner = groups["users"][website["owner_id"]]
        owner["applications"].append(
            (str(website["id"]), website["domain"], website["name"])
        )

    accounts = itertools.chain(
        groups["users"].items(), groups["organisations"].items()
    )

    def sort_applications(items):
        return sorted(items, key=lambda x: x[0].lower())

    # print via pager
    if grouped:
        output_items = []
        for group, data in accounts:
            applications = data["applications"]
            if applications:
                output_items.append(
                    "{title}\n{line}\n\n{table}\n\n".format(
                        title=data["name"],
                        line="=" * len(data["name"]),
                        table=table(
                            sort_applications(applications), header[:3]
                        ),
                    )
                )
        output = os.linesep.join(output_items).rstrip(os.linesep)
    else:
        # add account name to all applications
        applications = [
            each + (data["name"],)
            for group, data in accounts
            for each in data["applications"]
        ]
        output = table(sort_applications(applications), header)

    click.echo_via_pager(output)


@app.command(name="deploy")
@click.argument("stage", default="test")
@pass_cli_context(allow_remote_id_override=True)
def application_deploy(ctx, remote_id, stage):
    """Deploy application."""
    ctx.client.deploy_application_or_get_progress(remote_id, stage)


@app.command(name="deploy-log")
@click.argument("stage", default="test")
@pass_cli_context(allow_remote_id_override=True)
def application_deploy_log(ctx, remote_id, stage):
    """View last deployment log."""
    ctx.client.show_deploy_log(remote_id, stage)


@app.command(name="logs")
@click.argument("stage", default="test")
@click.option(
    "--tail", "tail", default=False, is_flag=True, help="Tail the output."
)
@click.option(
    "--utc", "utc", default=False, is_flag=True, help="Show times in UTC/"
)
@pass_cli_context(allow_remote_id_override=True)
def application_logs(ctx, remote_id, stage, tail, utc):
    """View logs."""
    ctx.client.show_log(remote_id, stage, tail, utc)


@app.command(name="ssh")
@click.argument("stage", default="test")
@pass_cli_context(allow_remote_id_override=True)
def application__ssh(ctx, remote_id, stage):
    """Establish SSH connection."""
    ctx.client.ssh(remote_id, stage)


@app.command(name="configure")
@pass_cli_context()
def configure(ctx):
    """Associate a local application with a Divio cloud applications."""
    localdev.configure(ctx)


@app.command(name="dashboard")
@pass_cli_context(allow_remote_id_override=True)
def application_dashboard(ctx, remote_id):
    """Open the application dashboard on the Divio Control Panel."""
    launch_url(get_cp_url(client=ctx.client, application_id=remote_id))


@app.command(name="up", aliases=["start"])
@pass_cli_context(require_app=True)
def application_up(ctx):
    """Start the local application (equivalent to: docker-compose up)."""
    localdev.start_application(ctx)


@app.command(name="down", aliases=["stop"])
@pass_cli_context(require_app=True)
def application_down(ctx):
    """Stop the local application."""
    localdev.stop_application(ctx)


@app.command(name="open")
@click.argument("stage", default="")
@pass_cli_context(allow_remote_id_override=True)
def application_open(ctx, remote_id, stage):
    """Open local or cloud applications in a browser."""
    if stage:
        open_application_cloud_site(
            ctx.client, application_id=remote_id, stage=stage
        )
    else:
        localdev.open_application(ctx)


@app.command(name="update")
@click.option(
    "--strict",
    "strict",
    default=False,
    is_flag=True,
    help="A strict update will fail on a warning.",
)
@pass_cli_context()
def application_update(ctx, strict):
    """Update the local application with new code changes, then build it.

    Runs:

    git pull
    docker-compose pull
    docker-compose build
    docker-compose run web start migrate"""

    localdev.update_local_application(
        ctx, get_git_checked_branch(), strict=strict
    )


@app.command(name="env-vars")
@click.option(
    "-s",
    "--stage",
    default="test",
    type=str,
    help="Manage the cloud application's environment variables.",
)
@click.option(
    "--all/--custom",
    "show_all_vars",
    default=False,
    help="--all shows automatically applied environment variables as well as user-specified variables.",
)
@click.option("--json", "as_json", is_flag=True, default=False)
@click.option(
    "--get",
    "get_vars",
    default=None,
    type=str,
    multiple=True,
    help="Get a specific environment variable.",
)
@click.option(
    "--set",
    "set_vars",
    default=None,
    type=click.Tuple([str, str]),
    multiple=True,
    help=(
        "Set a specific custom environment variable\n\n"
        "example: divio app env-vars set DEBUG False"
    ),
)
@click.option(
    "--unset",
    "unset_vars",
    default=None,
    type=str,
    multiple=True,
    help="Remove an environment variable.",
)
@pass_cli_context(allow_remote_id_override=True)
def environment_variables(
    ctx,
    remote_id,
    stage,
    show_all_vars,
    as_json,
    get_vars,
    set_vars,
    unset_vars,
):
    """
    Get and set environment vars.

    WARNING: This command is experimental and may change in a future release.
    """
    stage = stage.lower()
    if set_vars or unset_vars:
        set_vars = dict(set_vars)
        data = ctx.client.set_custom_environment_variables(
            website_id=remote_id,
            stage=stage,
            set_vars=set_vars,
            unset_vars=unset_vars,
        )
    else:
        data = ctx.client.get_environment_variables(
            website_id=remote_id, stage=stage, custom_only=not show_all_vars
        )
        if get_vars:
            data = {
                key: value for key, value in data.items() if key in get_vars
            }
    if as_json:
        click.echo(json.dumps(data, indent=2, sort_keys=True))
    else:
        header = ("Key", "Value")
        data = sorted([(key, value) for key, value in data.items()])
        output = table(data, header)
        click.echo_via_pager(output)


@app.command(name="status")
@pass_cli_context(require_app=True)
def app_status(ctx):
    """Show local application status."""
    localdev.show_application_status(ctx)


@app.command(name="setup")
@click.argument("slug")
@click.option(
    "-s",
    "--stage",
    default="test",
    help="Specify environment from which media and content data will be pulled.",
)
@click.option(
    "-p",
    "--path",
    default=".",
    help="Install application in path.",
    type=click.Path(writable=True, readable=True),
)
@click.option(
    "--overwrite",
    is_flag=True,
    default=False,
    help="Overwrite the application directory if it already exists.",
)
@click.option(
    "--skip-doctor",
    is_flag=True,
    default=False,
    help="Skip system test before setting up the application.",
)
@pass_cli_context()
def application_setup(ctx, slug, stage, path, overwrite, skip_doctor):
    """Set up a development environment for a Divio application."""
    if not skip_doctor and not check_requirements_human(ctx, silent=True):
        click.secho(
            "There was a problem while checking your system. Please run "
            "'divio doctor'.",
            fg="red",
        )
        sys.exit(1)

    localdev.create_workspace(ctx, slug, stage, path, overwrite)


@app.group(name="pull")
def application_pull():
    """Pull db or files from the Divio cloud environment."""


@application_pull.command(name="db")
@click.option(
    "--keep-tempfile",
    is_flag=True,
    default=False,
    help="Keep the temporary file with the data.",
)
@click.argument("stage", default="test")
@click.argument("prefix", default=localdev.DEFAULT_SERVICE_PREFIX)
@pass_cli_context(require_app=True, allow_remote_id_override=True)
def pull_db(ctx, remote_id, stage, prefix, keep_tempfile):
    """
    Pull database the Divio cloud environment.
    """
    from .localdev import utils

    db_type = utils.get_db_type(ctx, prefix)
    dump_path = ctx.app_path / settings.DIVIO_DUMP_FOLDER

    localdev.ImportRemoteDatabase(
        context=ctx,
        stage=stage,
        prefix=prefix,
        remote_id=remote_id,
        db_type=db_type,
        dump_path=dump_path,
        keep_tempfile=keep_tempfile,
    )()


@application_pull.command(name="media")
@click.argument("stage", default="test")
@pass_cli_context(require_app=True, allow_remote_id_override=True)
def pull_media(ctx, remote_id, stage):
    """
    Pull media files from the Divio cloud environment.
    """
    localdev.pull_media(ctx, stage=stage, remote_id=remote_id)


@app.group(name="push")
def application_push():
    """Push db or media files to the Divio cloud environment."""


@application_push.command(name="db")
@click.argument("stage", default="test")
@click.option(
    "-d",
    "--dumpfile",
    default=None,
    type=click.Path(exists=True),
    help="Specify a dumped database file to upload.",
)
@click.option(
    "--noinput",
    is_flag=True,
    default=False,
    help="Don't ask for confirmation.",
)
@click.argument("prefix", default=localdev.DEFAULT_SERVICE_PREFIX)
@pass_cli_context(require_app=True, allow_remote_id_override=True)
def push_db(ctx, remote_id, prefix, stage, dumpfile, noinput):
    """
    Push database to the Divio cloud environment..
    """
    from .localdev import utils

    db_type = utils.get_db_type(ctx, prefix)
    if not dumpfile:
        if not noinput:
            click.secho(messages.PUSH_DB_WARNING.format(stage=stage), fg="red")
            if not click.confirm("\nAre you sure you want to continue?"):
                return
        localdev.push_db(
            ctx,
            stage=stage,
            remote_id=remote_id,
            prefix=prefix,
            db_type=db_type,
        )
    else:
        if not noinput:
            click.secho(messages.PUSH_DB_WARNING.format(stage=stage), fg="red")
            if not click.confirm("\nAre you sure you want to continue?"):
                return
        localdev.push_local_db(
            ctx,
            stage=stage,
            dump_filename=dumpfile,
            website_id=remote_id,
            prefix=prefix,
        )


@application_push.command(name="media")
@click.argument("stage", default="test")
@click.option(
    "--noinput",
    is_flag=True,
    default=False,
    help="Don't ask for confirmation.",
)
@click.argument("prefix", default=localdev.DEFAULT_SERVICE_PREFIX)
@pass_cli_context(require_app=True, allow_remote_id_override=True)
def push_media(ctx, remote_id, prefix, stage, noinput):
    """
    Push database to the Divio cloud environment..
    """

    if not noinput:
        click.secho(messages.PUSH_MEDIA_WARNING.format(stage=stage), fg="red")
        if not click.confirm("\nAre you sure you want to continue?"):
            return
    localdev.push_media(
        ctx, stage=stage, remote_id=remote_id, prefix=prefix
    )


@app.group(name="import")
def application_import():
    """Import local database dump."""


@application_import.command(name="db")
@click.argument("prefix", default=localdev.DEFAULT_SERVICE_PREFIX)
@click.argument(
    "dump-path",
    default=localdev.DEFAULT_DUMP_FILENAME,
    type=click.Path(exists=True),
)
@pass_cli_context(require_app=True)
def import_db(ctx, dump_path, prefix):
    """
    Load a database dump into your local database.
    """
    from .localdev import utils

    db_type = utils.get_db_type(ctx, prefix)
    localdev.ImportLocalDatabase(
        context=ctx,
        custom_dump_path=dump_path,
        prefix=prefix,
        db_type=db_type,
    )()


@app.group(name="export")
def application_export():
    """Export local database dump."""


@application_export.command(name="db")
@click.argument("prefix", default=localdev.DEFAULT_SERVICE_PREFIX)
@pass_cli_context(require_app=True)
def export_db(ctx, prefix):
    """
    Export a dump of your local database
    """
    localdev.export_db(ctx, prefix=prefix)


@app.command(name="develop")
@click.argument("package")
@click.option(
    "--no-rebuild",
    is_flag=True,
    default=False,
    help="Do not rebuild docker container automatically.",
)
@pass_cli_context(require_app=True)
def application_develop(ctx, package, no_rebuild):
    """Add a package 'package' to your local application environment."""
    localdev.develop_package(ctz, package, no_rebuild)


@cli.group()
@click.option("-p", "--path", default=".", help="Addon directory")
def addon(path):
    """Validate and upload addons packages to the Divio cloud."""


@addon.command(name="validate")
@click.pass_context
def addon_validate(ctx):
    """Validate addon configuration."""
    try:
        validate_addon(ctx.parent.params["path"])
    except exceptions.DivioException as exc:
        raise click.ClickException(*exc.args)
    click.echo("Addon is valid!")


@addon.command(name="upload")
@click.pass_context
def addon_upload(ctx):
    """Upload addon to the Divio Control Panel."""
    try:
        ret = upload_addon(ctx.obj.client, ctx.parent.params["path"])
    except exceptions.DivioException as exc:
        raise click.ClickException(*exc.args)
    click.echo(ret)


@addon.command(name="register")
@click.argument("verbose_name")
@click.argument("package_name")
@click.option(
    "-o",
    "--organisation",
    help="Register an addon for an organisation.",
    type=int,
)
@pass_cli_context()
def addon_register(ctx, package_name, verbose_name, organisation):
    """Register your addon on the Divio Control Panel\n
    - Verbose Name:        Name of the Addon as it appears in the Marketplace
    - Package Name:        System wide unique Python package name
    """
    ret = ctx.client.register_addon(package_name, verbose_name, organisation)
    click.echo(ret)


@cli.group()
@click.option("-p", "--path", default=".", help="Boilerplate directory")
@pass_cli_context()
def boilerplate(path):
    """Validate and upload boilerplate packages to the Divio cloud."""


@boilerplate.command(name="validate")
@click.pass_context
def boilerplate_validate(ctx):
    """Validate boilerplate configuration."""
    try:
        validate_boilerplate(ctx.parent.params["path"])
    except exceptions.DivioException as exc:
        raise click.ClickException(*exc.args)
    click.echo("Boilerplate is valid.")


@boilerplate.command(name="upload")
@click.option(
    "--noinput",
    is_flag=True,
    default=False,
    help="Don't ask for confirmation.",
)
@click.pass_context
def boilerplate_upload(ctx, noinput):
    """Upload boilerplate to the Divio Control Panel."""
    try:
        ret = upload_boilerplate(
            ctx.obj.client, ctx.parent.params["path"], noinput
        )
    except exceptions.DivioException as exc:
        raise click.ClickException(*exc.args)
    click.echo(ret)


@cli.command()
@click.option(
    "-s",
    "--skip-check",
    is_flag=True,
    default=False,
    help="Don't check PyPI for newer version.",
)
@click.option("-m", "--machine-readable", is_flag=True, default=False)
@pass_cli_context()
def version(ctx, skip_check, machine_readable):
    """Show version info."""
    if skip_check:
        from . import __version__

        update_info = {"current": __version__}
    else:
        update_info = ctx.client.config.check_for_updates(force=True)

    update_info["location"] = os.path.dirname(os.path.realpath(sys.executable))

    if machine_readable:
        click.echo(json.dumps(update_info))
    else:
        click.echo(
            "divio-cli {} from {}\n".format(
                update_info["current"], update_info["location"]
            )
        )

        if not skip_check:
            if update_info["update_available"]:
                click.secho(
                    "New version {version} is available. Upgrade options:\n\n"
                    " - Using pip\n"
                    "   pip install --upgrade divio-cli\n\n"
                    " - Download the latest release from GitHub\n"
                    "   https://github.com/divio/divio-cli/releases".format(
                        version=update_info["remote"]
                    ),
                    fg="yellow",
                )
            elif update_info["pypi_error"]:
                click.secho(
                    "There was an error while trying to check for the latest "
                    "version on pypi.python.org:\n"
                    "{}".format(update_info["pypi_error"]),
                    fg="red",
                )
            else:
                click.echo("You have the latest version of divio-cli.")


@cli.command()
@click.option("-m", "--machine-readable", is_flag=True, default=False)
@click.option("-c", "--checks", default=None)
@pass_cli_context()
def doctor(ctx, machine_readable, checks):
    """Check that your system meets the development requirements.

    To disable checks selectively in case of false positives, see
    https://docs.divio.com/en/latest/reference/divio-cli/#using-skip-doctor-checks"""

    if checks:
        checks = checks.split(",")

    if machine_readable:
        errors = {
            check: error
            for check, check_name, error in check_requirements(ctx, checks)
        }
        exitcode = 1 if any(errors.values()) else 0
        click.echo(json.dumps(errors), nl=False)
    else:
        click.echo("Verifying your system setup...")
        exitcode = 0 if check_requirements_human(ctx, checks) else 1

    sys.exit(exitcode)
